; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\spi.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\spi.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\Basic\inc -I..\CMSIS -I..\Connectivity\IIC -I..\Connectivity\SPI -I..\Connectivity\USART -I..\HardWare\BMM150 -I..\HardWare\BUZZER -I..\HardWare\LED -I..\System\delay -I..\System\stm32f4xx_it -I..\System\sys -I..\System\system_stm32f4xx -I..\User -I..\System -I.\RTE\_Target_1 -ID:\ProgramFile\Keil5\Keil\STM32F4xx_DFP\2.13.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -ID:\ProgramFile\Keil5\ARM\CMSIS\Include -D__UVISION_VERSION=525 -DSTM32F405xx -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER --omf_browse=.\objects\spi.crf ..\Connectivity\SPI\spi.c]
                          THUMB

                          AREA ||i.SPI1_Configuration||, CODE, READONLY, ALIGN=2

                  SPI1_Configuration PROC
;;;3      #ifdef EN_SPI1
;;;4      void SPI1_Configuration(void)
000000  b500              PUSH     {lr}
;;;5      {	 
000002  b087              SUB      sp,sp,#0x1c
;;;6          GPIO_InitTypeDef  GPIO_InitStructure;
;;;7          SPI_InitTypeDef  SPI_InitStructure;
;;;8          //开启时钟
;;;9          RCC_AHB1PeriphClockCmd(SPI1_GPIO_CLK, ENABLE);//使能GPIOB时钟
000004  2101              MOVS     r1,#1
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;10         RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);//使能SPI1时钟
00000c  2101              MOVS     r1,#1
00000e  0308              LSLS     r0,r1,#12
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;11         //GPIO初始化设置
;;;12         GPIO_InitStructure.GPIO_Pin = SPI1_SCK|SPI1_MISO|SPI1_MOSI;//PB3~5复用功能输出	
000014  20e0              MOVS     r0,#0xe0
000016  9005              STR      r0,[sp,#0x14]
;;;13         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;//复用功能
000018  2002              MOVS     r0,#2
00001a  f88d0018          STRB     r0,[sp,#0x18]
;;;14         GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;//推挽输出
00001e  2000              MOVS     r0,#0
000020  f88d001a          STRB     r0,[sp,#0x1a]
;;;15         GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;//100MHz
000024  2003              MOVS     r0,#3
000026  f88d0019          STRB     r0,[sp,#0x19]
;;;16         GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;//上拉
00002a  2001              MOVS     r0,#1
00002c  f88d001b          STRB     r0,[sp,#0x1b]
;;;17         GPIO_Init(SPI1_Port, &GPIO_InitStructure);//初始化
000030  a905              ADD      r1,sp,#0x14
000032  481b              LDR      r0,|L1.160|
000034  f7fffffe          BL       GPIO_Init
;;;18     
;;;19         GPIO_PinAFConfig(SPI1_Port,SPI1_Pinsourse_SCK,GPIO_AF_SPI1); //PB3复用为 SPI1
000038  2205              MOVS     r2,#5
00003a  4611              MOV      r1,r2
00003c  4818              LDR      r0,|L1.160|
00003e  f7fffffe          BL       GPIO_PinAFConfig
;;;20         GPIO_PinAFConfig(SPI1_Port,SPI1_Pinsourse_MISO,GPIO_AF_SPI1); //PB4复用为 SPI1
000042  2205              MOVS     r2,#5
000044  2106              MOVS     r1,#6
000046  4816              LDR      r0,|L1.160|
000048  f7fffffe          BL       GPIO_PinAFConfig
;;;21         GPIO_PinAFConfig(SPI1_Port,SPI1_Pinsourse_MOSI,GPIO_AF_SPI1); //PB5复用为 SPI1
00004c  2205              MOVS     r2,#5
00004e  2107              MOVS     r1,#7
000050  4813              LDR      r0,|L1.160|
000052  f7fffffe          BL       GPIO_PinAFConfig
;;;22     
;;;23         SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;  //设置SPI单向或者双向的数据模式:SPI设置为双线双向全双工
000056  2000              MOVS     r0,#0
000058  f8ad0000          STRH     r0,[sp,#0]
;;;24         SPI_InitStructure.SPI_Mode = SPI_Mode_Master;		//设置SPI工作模式:设置为主SPI
00005c  f44f7082          MOV      r0,#0x104
000060  f8ad0002          STRH     r0,[sp,#2]
;;;25         SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;		//设置SPI的数据大小:SPI发送接收8位帧结构
000064  2000              MOVS     r0,#0
000066  f8ad0004          STRH     r0,[sp,#4]
;;;26         SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;		//串行同步时钟的空闲状态为高电平
00006a  f8ad0006          STRH     r0,[sp,#6]
;;;27         SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;	//串行同步时钟的第一个跳变沿（上升或下降）数据被采样
00006e  f8ad0008          STRH     r0,[sp,#8]
;;;28         SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;		//NSS信号由硬件（NSS管脚）还是软件（使用SSI位）管理:内部NSS信号有SSI位控制
000072  f44f7000          MOV      r0,#0x200
000076  f8ad000a          STRH     r0,[sp,#0xa]
;;;29         SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_64;		//定义波特率预分频的值:波特率预分频值为256
00007a  2028              MOVS     r0,#0x28
00007c  f8ad000c          STRH     r0,[sp,#0xc]
;;;30         SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;	//指定数据传输从MSB位还是LSB位开始:数据传输从MSB位开始
000080  2000              MOVS     r0,#0
000082  f8ad000e          STRH     r0,[sp,#0xe]
;;;31         SPI_InitStructure.SPI_CRCPolynomial = 7;	//CRC值计算的多项式
000086  2007              MOVS     r0,#7
000088  f8ad0010          STRH     r0,[sp,#0x10]
;;;32         SPI_Init(SPI1, &SPI_InitStructure);  //根据SPI_InitStruct中指定的参数初始化外设SPIx寄存器
00008c  4669              MOV      r1,sp
00008e  4805              LDR      r0,|L1.164|
000090  f7fffffe          BL       SPI_Init
;;;33         SPI_Cmd(SPI1, ENABLE); //使能SPI外设		 
000094  2101              MOVS     r1,#1
000096  4803              LDR      r0,|L1.164|
000098  f7fffffe          BL       SPI_Cmd
;;;34     }   
00009c  b007              ADD      sp,sp,#0x1c
00009e  bd00              POP      {pc}
;;;35     #endif
                          ENDP

                  |L1.160|
                          DCD      0x40020000
                  |L1.164|
                          DCD      0x40013000

                          AREA ||i.SPI2_Configuration||, CODE, READONLY, ALIGN=2

                  SPI2_Configuration PROC
;;;37     #ifdef EN_SPI2
;;;38     void SPI2_Configuration(void)
000000  b500              PUSH     {lr}
;;;39     {	 
000002  b087              SUB      sp,sp,#0x1c
;;;40         GPIO_InitTypeDef  GPIO_InitStructure;
;;;41         SPI_InitTypeDef  SPI_InitStructure;
;;;42         //开启时钟
;;;43         RCC_AHB1PeriphClockCmd(SPI2_GPIO_CLK, ENABLE);//使能GPIOB时钟
000004  2101              MOVS     r1,#1
000006  2002              MOVS     r0,#2
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;44         RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE);//使能SPI1时钟
00000c  2101              MOVS     r1,#1
00000e  0388              LSLS     r0,r1,#14
000010  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;45         //GPIO初始化设置
;;;46         GPIO_InitStructure.GPIO_Pin = SPI2_SCK|SPI2_MISO|SPI2_MOSI;//PB3~5复用功能输出	
000014  f44f4060          MOV      r0,#0xe000
000018  9005              STR      r0,[sp,#0x14]
;;;47         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;//复用功能
00001a  2002              MOVS     r0,#2
00001c  f88d0018          STRB     r0,[sp,#0x18]
;;;48         GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;//推挽输出
000020  2000              MOVS     r0,#0
000022  f88d001a          STRB     r0,[sp,#0x1a]
;;;49         GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;//100MHz
000026  2003              MOVS     r0,#3
000028  f88d0019          STRB     r0,[sp,#0x19]
;;;50         GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;//上拉
00002c  2001              MOVS     r0,#1
00002e  f88d001b          STRB     r0,[sp,#0x1b]
;;;51         GPIO_Init(SPI2_Port, &GPIO_InitStructure);//初始化
000032  a905              ADD      r1,sp,#0x14
000034  481b              LDR      r0,|L2.164|
000036  f7fffffe          BL       GPIO_Init
;;;52     
;;;53         GPIO_PinAFConfig(SPI2_Port,SPI2_Pinsourse_SCK,GPIO_AF_SPI2); //PB3复用为 SPI1
00003a  2205              MOVS     r2,#5
00003c  210d              MOVS     r1,#0xd
00003e  4819              LDR      r0,|L2.164|
000040  f7fffffe          BL       GPIO_PinAFConfig
;;;54         GPIO_PinAFConfig(SPI2_Port,SPI2_Pinsourse_MISO,GPIO_AF_SPI2); //PB4复用为 SPI1
000044  2205              MOVS     r2,#5
000046  210e              MOVS     r1,#0xe
000048  4816              LDR      r0,|L2.164|
00004a  f7fffffe          BL       GPIO_PinAFConfig
;;;55         GPIO_PinAFConfig(SPI2_Port,SPI2_Pinsourse_MOSI,GPIO_AF_SPI2); //PB5复用为 SPI1
00004e  2205              MOVS     r2,#5
000050  210f              MOVS     r1,#0xf
000052  4814              LDR      r0,|L2.164|
000054  f7fffffe          BL       GPIO_PinAFConfig
;;;56     
;;;57         SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;  //设置SPI单向或者双向的数据模式:SPI设置为双线双向全双工
000058  2000              MOVS     r0,#0
00005a  f8ad0000          STRH     r0,[sp,#0]
;;;58         SPI_InitStructure.SPI_Mode = SPI_Mode_Master;		//设置SPI工作模式:设置为主SPI
00005e  f44f7082          MOV      r0,#0x104
000062  f8ad0002          STRH     r0,[sp,#2]
;;;59         SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;		//设置SPI的数据大小:SPI发送接收8位帧结构
000066  2000              MOVS     r0,#0
000068  f8ad0004          STRH     r0,[sp,#4]
;;;60         SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;		//串行同步时钟的空闲状态为高电平
00006c  2002              MOVS     r0,#2
00006e  f8ad0006          STRH     r0,[sp,#6]
;;;61         SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;	//串行同步时钟的第二个跳变沿（上升或下降）数据被采样
000072  2001              MOVS     r0,#1
000074  f8ad0008          STRH     r0,[sp,#8]
;;;62         SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;		//NSS信号由硬件（NSS管脚）还是软件（使用SSI位）管理:内部NSS信号有SSI位控制
000078  0240              LSLS     r0,r0,#9
00007a  f8ad000a          STRH     r0,[sp,#0xa]
;;;63         SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_128;		//定义波特率预分频的值:波特率预分频值为256
00007e  2030              MOVS     r0,#0x30
000080  f8ad000c          STRH     r0,[sp,#0xc]
;;;64         SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_LSB;	//指定数据传输从MSB位还是LSB位开始:数据传输从MSB位开始
000084  2080              MOVS     r0,#0x80
000086  f8ad000e          STRH     r0,[sp,#0xe]
;;;65         SPI_InitStructure.SPI_CRCPolynomial = 7;	//CRC值计算的多项式
00008a  2007              MOVS     r0,#7
00008c  f8ad0010          STRH     r0,[sp,#0x10]
;;;66         SPI_Init(SPI2, &SPI_InitStructure);  //根据SPI_InitStruct中指定的参数初始化外设SPIx寄存器
000090  4669              MOV      r1,sp
000092  4805              LDR      r0,|L2.168|
000094  f7fffffe          BL       SPI_Init
;;;67         SPI_Cmd(SPI2, ENABLE); //使能SPI外设		 
000098  2101              MOVS     r1,#1
00009a  4803              LDR      r0,|L2.168|
00009c  f7fffffe          BL       SPI_Cmd
;;;68     }   
0000a0  b007              ADD      sp,sp,#0x1c
0000a2  bd00              POP      {pc}
;;;69     #endif
                          ENDP

                  |L2.164|
                          DCD      0x40020400
                  |L2.168|
                          DCD      0x40003800

                          AREA ||i.SPI_ReadWriteByte||, CODE, READONLY, ALIGN=1

                  SPI_ReadWriteByte PROC
;;;70     
;;;71     uint16_t SPI_ReadWriteByte(SPI_TypeDef*SPI,uint16_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;72     {		 			 
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;73         while (SPI_I2S_GetFlagStatus(SPI,SPI_I2S_FLAG_TXE) == RESET){}//等待发送区空  
000006  bf00              NOP      
                  |L3.8|
000008  2102              MOVS     r1,#2
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       SPI_I2S_GetFlagStatus
000010  2800              CMP      r0,#0
000012  d0f9              BEQ      |L3.8|
;;;74         SPI_I2S_SendData(SPI, Data); //通过外设SPIx发送一个byte  数据	
000014  4629              MOV      r1,r5
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       SPI_I2S_SendData
;;;75         while (SPI_I2S_GetFlagStatus(SPI,SPI_I2S_FLAG_RXNE) == RESET){} //等待接收完一个byte  
00001c  bf00              NOP      
                  |L3.30|
00001e  2101              MOVS     r1,#1
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       SPI_I2S_GetFlagStatus
000026  2800              CMP      r0,#0
000028  d0f9              BEQ      |L3.30|
;;;76         return SPI_I2S_ReceiveData(SPI); //返回通过SPIx最近接收的数据			    
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       SPI_I2S_ReceiveData
;;;77     }
000030  bd70              POP      {r4-r6,pc}
;;;78     
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Connectivity\\SPI\\spi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_spi_c_bd8a9708____REV16|
#line 129 "..\\CMSIS\\core_cmInstr.h"
|__asm___5_spi_c_bd8a9708____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_spi_c_bd8a9708____REVSH|
#line 144
|__asm___5_spi_c_bd8a9708____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
